name: build kernel

on:
  workflow_call:
    inputs:
      device:
        required: true
        type: string
      ksu_type:
        required: true
        type: string
      susfs:
        required: true
        type: string
      stock_ota:
        required: true
        type: string
      pixel-source-branch:
        required: true
        type: string
      aosp-spoofing:
        required: false
        type: string
      hooks_type:
        required: true
        type: string
      disable_susfs_patches:
        required: false
        type: string
      
permissions:
  contents: write
  actions: write 

jobs:
  build-pixel-kernel:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    env:
      KERNEL_VER: ''
      KSUVER: ''
      SUSFS_STAT: ''
      ZIP_NAME: ''
      BOOT_NAME: ''
      VENDOR_NAME: ''

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

#      - name: Maximize Build Space
#        uses: AdityaGarg8/remove-unwanted-software@v5
#        with:
#          remove-dotnet: 'true'          # Frees ~2 GB
#          remove-android: 'true'         # Frees ~9 GB
#          remove-haskell: 'true'         # Frees ~5.2 GB
#          remove-codeql: 'true'          # Frees ~5.4 GB
#          remove-docker-images: 'true'   # Frees ~3.2 GB
#          remove-large-packages: 'true'  # Frees ~3.1 GB
#          remove-swapfile: 'true'        # Frees ~4 GB
#          remove-cached-tools: 'false'   # Avoid unless confirmed safe
#          verbose: 'true'                # Enable detailed logging

      - name: Install Build Dependencies
        run: sudo apt-get update && sudo apt-get install -y wget unzip jq libelf-dev libssl-dev build-essential cmake g++ xxd

      - name: Install Repo
        run: |
          mkdir -p .bin
          curl https://storage.googleapis.com/git-repo-downloads/repo > .bin/repo
          chmod a+rx .bin/repo
          echo "$GITHUB_WORKSPACE/.bin" >> $GITHUB_PATH

      - name: Setup Android NDK
        if: ${{ inputs.ksu_type == 'suki-su' }}
        id: setup-ndk
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r26d
          add-to-path: false
        
      - name: Set NDK_HOME and ANDROID_NDK_HOME Environment Variables
        if: ${{ inputs.ksu_type == 'suki-su' }}
        run: |
          echo "NDK_HOME=${{ steps.setup-ndk.outputs.ndk-path }}" >> $GITHUB_ENV
          echo "ANDROID_NDK_HOME=${{ steps.setup-ndk.outputs.ndk-path }}" >> $GITHUB_ENV
          echo "NDK_HOME set to: ${{ env.NDK_HOME }}"
          echo "ANDROID_NDK_HOME set to: ${{ env.ANDROID_NDK_HOME }}"

      - name: Determine Kernel Build Variables for KPM
        if: ${{ inputs.ksu_type == 'suki-su' }}
        run: |
          echo "Determining ARCH and CROSS_COMPILE for KPM components build..."
          echo "ARCH=arm64" >> $GITHUB_ENV
          echo "CROSS_COMPILE=aarch64-linux-android-" >> $GITHUB_ENV
          echo "Detected ARCH: ${{ env.ARCH }}"
          echo "Detected CROSS_COMPILE: ${{ env.CROSS_COMPILE }}"
          echo "Detected NDK_HOME: ${{ env.NDK_HOME }}"
          echo "Detected ANDROID_NDK_HOME: ${{ env.ANDROID_NDK_HOME }}"

      - name: Clone AnyKernel3, KernelPatches and SUSFS
        run: |
          echo "Cloning AnyKernel3 and other dependencies..."
          # Клонирую репозиторий с патчами, susfs и AK3. 
          git -c credential.helper= clone https://github.com/etherealNest/AnyKernel3 -b "${{ inputs.device }}"
          git clone https://gitlab.com/simonpunk/susfs4ksu.git -b "gki-android14-6.1"
          git -c credential.helper= clone https://github.com/etherealNest/kernel_patches.git
          git -c credential.helper= clone https://github.com/SukiSU-Ultra/SukiSU_KernelPatch_patch.git

      - name: Execute SukiSU_KernelPatch_patch build.sh with patching
        if: ${{ inputs.ksu_type == 'suki-su' }}
        run: |
          echo "Preparing and executing SukiSU_KernelPatch_patch/build.sh..."
          KPM_REPO_PATH="${GITHUB_WORKSPACE}/SukiSU_KernelPatch_patch"
          
          echo "Patching SukiSU_KernelPatch_patch/build.sh for NDK_HOME, ANDROID_NDK, and ANDROID_PLATFORM..."
          sed -i "s|export NDK_HOME=.*|export NDK_HOME=\"${NDK_HOME}\"|g" "${KPM_REPO_PATH}/build.sh"
          sed -i "s|export ANDROID_NDK=.*|export ANDROID_NDK=\"${ANDROID_NDK_HOME}\"|g" "${KPM_REPO_PATH}/build.sh"
          sed -i "s|-DANDROID_PLATFORM=android-33|-DANDROID_PLATFORM=android-34|g" "${KPM_REPO_PATH}/build.sh"

          echo "Patching SukiSU_KernelPatch_patch/kernel/Makefile for TARGET_COMPILE and compiler version..."
          sed -i "s|TARGET_COMPILE=/root/.android/sdk/ndk/28.0.13004108/toolchains/llvm/prebuilt/linux-x86_64/bin|TARGET_COMPILE=\"${NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin\"|g" "${KPM_REPO_PATH}/kernel/Makefile"
          
          # ЭТО НОВОЕ КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ: Замена версии API в имени компилятора
          sed -i 's|aarch64-linux-android35-clang|aarch64-linux-android34-clang|g' "${KPM_REPO_PATH}/kernel/Makefile"
          
          chmod +x "${KPM_REPO_PATH}/build.sh"

          cd "${KPM_REPO_PATH}"
          ./build.sh
          if [ $? -ne 0 ]; then
            echo "SukiSU_KernelPatch_patch/build.sh failed."
            exit 1
          fi
          echo "SukiSU_KernelPatch_patch/build.sh executed successfully."

      - name: Start VS Code
        if: always()      
        uses: fawazahmed0/action-debug-vscode@main
        with:
          port: 8080
          folder: ${{ github.workspace }}
          github_token: ${{ secrets.GITHUB_TOKEN }}


      - name: Getting magiskboot tool
        run: |
          set -e
          # Получаем утилиту magiskboot напрямую из последней версии apk.
          # Она нам нужна чтобы в будущем из стоковых .img подменить Image.lz4.

          MKBOOTIMG_DIR="FilesForImg"

          mkdir -p "${MKBOOTIMG_DIR}/tools" "magisk_unzip"

          curl -s https://api.github.com/repos/topjohnwu/Magisk/releases \
            | jq -r '.[0].assets[] 
                      | select(.name | test("^Magisk.*\\.apk$")) 
                      | .browser_download_url' \
            | xargs -n1 wget -q

          unzip -q -o Magisk*.apk -d magisk_unzip
          cp magisk_unzip/lib/x86_64/libmagiskboot.so ${MKBOOTIMG_DIR}/tools/magiskboot
          chmod 775 ${MKBOOTIMG_DIR}/tools/magiskboot
          ls -l ${MKBOOTIMG_DIR}/tools
          echo "Lust version magiskboot successfully downloaded, redy to use"

          rm -rf Magisk*.apk magisk_unzip
          
      - name: Download offical firmware for geting stock .img
        run: |
          set -e
          # Скчиваем стоковую прошивку для получения стоковых .img.

          DOWN_URL="https://dl.google.com/dl/android/aosp/"
          MKBOOTIMG_DIR="FilesForImg"

          wget --progress=dot:mega "${DOWN_URL}${{ inputs.stock_ota }}"
          echo "Stock firmware downloaded"

          mkdir -p "firmware/imgs" "${MKBOOTIMG_DIR}/assets"
          unzip -o "${{ inputs.stock_ota }}" '*.zip' -d firmware
          INNER_ZIP=$(find firmware -type f -name '*.zip' | head -n1)
          unzip -o "$INNER_ZIP" 'boot.img' 'vendor_kernel_boot.img' -d firmware/imgs

          cp \
            "firmware/imgs/boot.img" \
            "firmware/imgs/vendor_kernel_boot.img" \
            "${MKBOOTIMG_DIR}/assets"
          echo "Requested stock .img copied"
          rm -rf firmware

      - name: Check Disk Space Before Sync
        run: |
          echo "Disk space before kernel source sync:"
          df -h

      - name: Initialize and Sync Kernel Source
        run: |
          KERNEL_DIR="kernel_source"
          MANIFEST_URL="https://android.googlesource.com/kernel/manifest"

          rm -rf "$KERNEL_DIR"
          mkdir -p "$KERNEL_DIR"
          cd "$KERNEL_DIR"

          repo init --depth=1 -u "$MANIFEST_URL" -b "${{ inputs.pixel-source-branch }}"

          if [ -n "${{ inputs.aosp-spoofing }}" ]; then
            echo "Overriding kernel/common revision to tag ${{ inputs.aosp-spoofing }}"
            sed -i "s|path=\"aosp\" name=\"kernel/common\"|path=\"aosp\" name=\"kernel/common\" revision=\"refs/tags/${{ inputs.aosp-spoofing }}\"|g" .repo/manifests/default.xml
          else
            echo "No AOSP spoofing input provided, using default manifest settings."
          fi

          echo "Syncing repositories..."
          repo sync -c -j$(nproc --all) --fail-fast --no-tags

      - name: Verify Kernel Version
        run: |
          cd kernel_source/aosp
          KERNEL_VER=$(sed -n '2,4p' Makefile | grep -oE '[0-9]+' | paste -sd '.')
          echo "KERNEL_VER=$KERNEL_VER" >> $GITHUB_ENV

          echo "Kernel version detected: ${KERNEL_VER}"

      - name: Determine Kernel Build Variables for KPM
        if: ${{ inputs.ksu_type == 'suki-su' }}
        run: |
          echo "Determining ARCH and CROSS_COMPILE for KPM components build..."
          # Для Pixel-устройств с AOSP GKI ядрами обычно ARCH arm64
          echo "ARCH=arm64" >> $GITHUB_ENV

          # CROSS_COMPILE обычно имеет вид aarch64-linux-gnu-
          # Ваш build_${{ inputs.device }}.sh скрипт должен устанавливать правильный тулчейн в PATH.
          # Если это не так, вам может потребоваться явно указать путь к CROSS_COMPILE (например, /path/to/toolchain/bin/aarch64-linux-gnu-).
          # Предполагаем стандартный aarch64-linux-gnu-
          echo "CROSS_COMPILE=aarch64-linux-gnu-" >> $GITHUB_ENV
          
          echo "Detected ARCH: ${{ env.ARCH }}"
          echo "Detected CROSS_COMPILE: ${{ env.CROSS_COMPILE }}"

      - name: Apply Build System Patch
        run: |
          # Патчитм BUILD.bazel чтобы явно заставить систему сборки использовать наши исходники.
          # Под каждое устройство нужно делать свой патч.

          echo "Applying build system patch..."
          PATCH_FILE=".github/workflows/Patches/fix_${{ inputs.device }}_BUILD.bazel.patch"
          TARGET_DIR="kernel_source/private/devices/google/${{ inputs.device }}"

          patch -p1 --forward -d "$TARGET_DIR" < "$PATCH_FILE"

          echo "Build system patch applied successfully."

      - name: Disable ABI Protected
        run: |
          # Очень важно, если не отключить на этом этапе ABI в дальнейшей сборке перестанут работать некоторые драйвера.
          sed -i '/^[[:space:]]*"protected_exports_list"[[:space:]]*:[[:space:]]*"android\/abi_gki_protected_exports_aarch64",$/d' ./kernel_source/aosp/BUILD.bazel
          rm -rf ./kernel_source/aosp/android/abi_gki_protected_exports_*

      - name: Add KernelSU
        working-directory: kernel_source/aosp
        run: |
          if [ "${{ inputs.ksu_type}}" == "ksu-next" ]; then
            echo "Adding KernelSU Next"
            curl -LSs "https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh" | bash -s next
          elif [ "${{ inputs.ksu_type}}" == "ksu" ]; then
            echo "Adding KernelSU"
            curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main
          elif [ "${{ inputs.ksu_type}}" == "suki-su" ]; then
            echo "Adding SukiSU-Ultra"
            curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s susfs-main
          fi

      - name: Apply SUSFS Patches
        if: ${{ inputs.susfs == 'true' }}
        working-directory: kernel_source/aosp
        run: |          
          echo "Applying SUSFS patches..."
          
          cp ../../susfs4ksu/kernel_patches/50_add_susfs_in_gki-android14-6.1.patch ./
          patch -p1 --forward < 50_add_susfs_in_gki-android14-6.1.patch
          cp ../../susfs4ksu/kernel_patches/fs/* ./fs/
          cp ../../susfs4ksu/kernel_patches/include/linux/* ./include/linux/
          
          if [ "${{ inputs.ksu_type }}" != 'suki-su' ]; then
            echo "Applying SUSFS patches for KernelSU Next..."
            # Тут будет интегрировать сам susfs с KernelSU Next

            if [ "${{ inputs.ksu_type }}" == "ksu-next" ]; then
              cd ./KernelSU-Next
            elif [ "${{ inputs.ksu_type }}" == "ksu" ]; then
              cd ./KernelSU
            fi

            # Для начала применяю самый основной патч, он ожидаемо должен завершиться с ошибкой.
            echo "Apply main patch"
            cp ../../../susfs4ksu/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch ./
            patch -p1 --forward < 10_enable_susfs_for_ksu.patch || true
          fi

          if [ "${{ inputs.ksu_type }}" == "ksu-next" ]; then
            # Применяю несколько мелких патчей к файлам к которым не мог применить основной патч.
            echo "STARTED fix for apk_sign.c"
            cp ../../../kernel_patches/next/susfs_fix_patches/v1.5.9/fix_apk_sign.c.patch ./
            patch -p1 --forward < fix_apk_sign.c.patch

            echo "STARTED fix for core_hook.c"
            cp ../../../kernel_patches/next/susfs_fix_patches/v1.5.9/fix_core_hook.c.patch ./
            patch -p1 --forward < fix_core_hook.c.patch

            echo "STARTED fix for sucompat.c"
            cp ../../../kernel_patches/next/susfs_fix_patches/v1.5.9/fix_sucompat.c.patch ./
            patch -p1 --forward < fix_sucompat.c.patch

            echo "STARTED fix for fix_kernel_compat.c.patch"
            cp ../../../kernel_patches/next/susfs_fix_patches/v1.5.9/fix_kernel_compat.c.patch ./
            patch -p1 --forward < fix_kernel_compat.c.patch
          fi

#      - name: Start VS Code
#        if: always()      
#        uses: fawazahmed0/action-debug-vscode@main
#        with:
#          port: 8080
#          folder: ${{ github.workspace }}
#          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get KernelSU Version
        working-directory: kernel_source/aosp
        run: |          
          if [ "${{ inputs.ksu_type}}" == "ksu-next" ]; then
            cd ./KernelSU-Next
          elif [ "${{ inputs.ksu_type }}" == "ksu" ]; then
            cd ./KernelSU
          elif [ "${{ inputs.ksu_type }}" == "suki-su" ]; then
            cd ./KernelSU
          fi

          # KernelSU Next определяет свою версию по количеству коммитов.

          # Базовая версия для подсчета
          if [ "${{ inputs.ksu_type }}" == "ksu-next" || "${{ inputs.ksu_type }}" == "ksu" ]; then
            BASE_VERSION=10200
          elif [ "${{ inputs.ksu_type }}" == "suki-su" ]; then
            BASE_VERSION=10700
          fi

          # Считаем коммиты в текущей директории и добавляем к базовой версии
          KSUVER=$(expr $(git rev-list --count HEAD) + $BASE_VERSION)
          
          echo "Detected KSUVER: $KSUVER"
          echo "KSUVER=$KSUVER" >> $GITHUB_ENV
          
      - name: Force KernelSU Driver Version
        if: ${{ inputs.ksu_type != 'suki-su' }}
        working-directory: kernel_source/aosp
        run: |
          echo "Forcing KSU Driver Version to ${KSUVER} in Makefile..."

          if [ "${{ inputs.ksu_type }}" == "ksu-next" ]; then
            cd ./KernelSU-Next/kernel
            STATIC_VERSION=11998
          elif [ "${{ inputs.ksu_type }}" == "ksu" ]; then
            cd ./KernelSU/kernel
            STATIC_VERSION=16
          elif [ "${{ inputs.ksu_type }}" == "suki-su" ]; then
            cd ./KernelSU/kernel
            STATIC_VERSION=13000
          fi

          # Нужно вручную подменить номер версии, это лишь визуальная часть.
          # Во время сборки bazel он выполняет всё в песочнице и Makefile попросту не видит папки .git для подсчёта версии.

          if [ "${{ inputs.ksu_type }}" == "ksu-next" || 'ksu' ]; then
            sed -i "s/ccflags-y += -DKSU_VERSION=${STATIC_VERSION}/ccflags-y += -DKSU_VERSION=${KSUVER}/" Makefile
          elif [ "${{ inputs.ksu_type }}" == "suki-su" ]; then
            sed -i "57s/${STATIC_VERSION}/${KSUVER}/" Makefile
          fi

          echo "Makefile patched successfully."

      - name: Apply Hooks Patches
        if: ${{ inputs.ksu_type == 'ksu-next' && inputs.hooks_type == 'manual' }}
        working-directory: kernel_source/aosp
        run: |
          # Позволяет использовать manual hooks для ядра.

          cp ../../kernel_patches/next/scope_min_manual_hooks_v1.4.patch ./
          patch -p1 --forward -F 3 < scope_min_manual_hooks_v1.4.patch

#      - name: Apply Hide Stuff Patches
#        working-directory: kernel_source/aosp
#        run: |
#          cp ../../kernel_patches/69_hide_stuff.patch ./
#          patch -p1 --forward -F 3 < 69_hide_stuff.patch

      - name: Add Configuration Settings
        working-directory: kernel_source/aosp
        run: |
          DEFCONFIG_PATH="../private/devices/google/${{ inputs.device }}/${{ inputs.device }}_defconfig"

          # Добавляем конфиги в defconfig устройства.
          echo "Adding configuration settings to defconfig..."
                    
          # KernelSU Core Configuration
          echo "CONFIG_KSU=y" >> "${DEFCONFIG_PATH}"

          if [ "${{ inputs.hooks_type }}" == "kprobes" ]; then
            if [ "${{ inputs.ksu_type }}" == "ksu-next" ]; then
              echo "CONFIG_KSU_KPROBES_HOOK=y" >> "${DEFCONFIG_PATH}"
            elif [ "${{ inputs.ksu_type }}" == "suki-su" ]; then
              echo "# CONFIG_KSU_MANUAL_HOOK is not set" >> "${DEFCONFIG_PATH}"
              echo "CONFIG_KPM=y" >> "${DEFCONFIG_PATH}"
            fi
            echo "CONFIG_KPROBES=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_HAVE_KPROBES=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KPROBE_EVENTS=y" >> "${DEFCONFIG_PATH}"
          elif [ "${{ inputs.hooks_type }}" == "manual" ]; then
            echo "# CONFIG_KSU_KPROBES_HOOK is not set" >> "${DEFCONFIG_PATH}"
          fi

          # Mountify Support
          if [ "${{ inputs.ksu_type }}" == "ksu" ]; then
            echo "CONFIG_OVERLAY_FS=y" >> "${DEFCONFIG_PATH}"
          fi
          echo "CONFIG_TMPFS_XATTR=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_TMPFS_POSIX_ACL=y" >> "${DEFCONFIG_PATH}"

          # Networking Configuration
          echo "CONFIG_IP_NF_TARGET_TTL=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP6_NF_TARGET_HL=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP6_NF_MATCH_HL=y" >> "${DEFCONFIG_PATH}"

          # BBR TCP Congestion Control
          echo "CONFIG_TCP_CONG_ADVANCED=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_TCP_CONG_BBR=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_NET_SCH_FQ=y" >> "${DEFCONFIG_PATH}"
          echo "# CONFIG_TCP_CONG_BIC is not set" >> "${DEFCONFIG_PATH}"
          echo "# CONFIG_TCP_CONG_WESTWOOD is not set" >> "${DEFCONFIG_PATH}"
          echo "# CONFIG_TCP_CONG_HTCP is not set" >> "${DEFCONFIG_PATH}"

          # IPSet support
          echo "CONFIG_IP_SET=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_MAX=256" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_BITMAP_IP=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_BITMAP_IPMAC=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_BITMAP_PORT=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_IP=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_IPPORT=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_IPPORTIP=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_IPPORTNET=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_NET=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_NETNET=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_NETPORT=y" >> "${DEFCONFIG_PATH}"
          echo "CONFIG_IP_SET_HASH_NETIFACE=y" >> "${DEFCONFIG_PATH}"

          if [ "${{ inputs.susfs }}" == "true" ]; then
            # SUSFS Configuration
            echo "CONFIG_KSU_SUSFS=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_SUS_PATH=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> "${DEFCONFIG_PATH}"
            
            # SUSFS Auto Mount Features
            echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_TRY_UMOUNT=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT=y" >> "${DEFCONFIG_PATH}"
            
            # SUSFS Advanced Features
            echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> "${DEFCONFIG_PATH}"
            # echo "# CONFIG_KSU_SUSFS_SUS_OVERLAYFS is not set" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_SPOOF_UNAME=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_OPEN_REDIRECT=y" >> "${DEFCONFIG_PATH}"
            
            # SUSFS Debugging and Security
            echo "CONFIG_KSU_SUSFS_ENABLE_LOG=y" >> "${DEFCONFIG_PATH}"
            echo "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y" >> "${DEFCONFIG_PATH}"
            echo "# CONFIG_KSU_SUSFS_SUS_SU is not set" >> "${DEFCONFIG_PATH}"
          fi

          echo "Showing updated defconfig:"
          cat "${DEFCONFIG_PATH}"

          # Удаление проверки defconfig
          sed -i 's/check_defconfig//' ./build.config.gki

      - name: Change Kernel Name
        working-directory: kernel_source
        run: |
          set -e
          # Удаляем надпись dirty из наименования ядра.
          sed -i "s/echo -n -dirty/echo -n \"\"/g" build/kernel/kleaf/workspace_status_stamp.py

          TIMESTAMP=$(date -u +'\"%a %b %d %T %Z %Y\"')
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV

          # Добавляем свою метку в название ядра. 
          # sed -i "\$s|echo \"\$res\"|echo \"\$res-NEXT-v${KSUVER}-SUSFS-v1.5.9\"|" ./aosp/scripts/setlocalversion
          sed -i "s/build-timestamp = \$(or \$(KBUILD_BUILD_TIMESTAMP), \$(build-timestamp-auto))/build-timestamp = ${TIMESTAMP}/" ./aosp/init/Makefile

      - name: Build Kernel
        working-directory: kernel_source
        run: |
          ./build_${{ inputs.device }}.sh --kernel_package=@//aosp

      - name: Patch Kernel Image with KPM
        if: ${{ inputs.ksu_type == 'suki-su' }}
        run: |
          echo "Patching kernel image with KPM..."
          KPM_REPO_PATH="${GITHUB_WORKSPACE}/SukiSU_KernelPatch_patch"
          ARTIFACT_DIR="${GITHUB_WORKSPACE}/kernel_source/out/${{ inputs.device }}/dist"
          ORIG_IMAGE="${ARTIFACT_DIR}/Image.lz4"
          PATCHED_IMAGE_TMP="${ARTIFACT_DIR}/Image.lz4.kpm_tmp"

          # Используем kptools-linux для хоста Ubuntu
          KPTOOLS_LINUX="${KPM_REPO_PATH}/patch/res/kptools-linux"
          KPIMG_EXEC="${KPM_REPO_PATH}/patch/res/kpimg"

          if [ ! -f "${KPTOOLS_LINUX}" ]; then
            echo "Error: kptools-linux executable not found at ${KPTOOLS_LINUX}. Did SukiSU.lz4"
          PATCHED_IMAGE_TMP="${ARTIFACT_DIR}/Image.lz4.kpm_tmp"

          # Используем kptools-linux для хоста Ubuntu
          KPTOOLS_LINUX="${KPM_REPO_PATH}/patch/res/kptools-linux"
          KPIMG_EXEC="${KPM_REPO_PATH}/patch/res/kpimg"

          if [ ! -f "${KPTOOLS_LINUX}" ]; then
            echo "Error: kptools-linux executable not found at ${KPTOOLS_LINUX}. Did SukiSU_KernelPatch_patch/build.sh fail?"
            exit 1
          fi
          if [ ! -f "${KPIMG_EXEC}" ]; then
            echo "Error: kpimg executable not found at ${KPIMG_EXEC}. Did SukiSU_KernelPatch_patch/build.sh fail?"
            exit 1
          fi
          if [ ! -f "${ORIG_IMAGE}" ]; then
            echo "Error: Original kernel image not found at ${ORIG_IMAGE}. Did the 'Build Kernel' step fail?"
            exit 1
          fi

          # Выполнение патчинга с использованием корректного инструмента и синтаксиса
          "${KPTOOLS_LINUX}" -p -i "${ORIG_IMAGE}" -k "${KPIMG_EXEC}" -o "${PATCHED_IMAGE_TMP}"
          if [ $? -ne 0 ]; then
            echo "Failed to patch kernel image with KPM using kptools-linux."
            exit 1
          fi

          mv "${PATCHED_IMAGE_TMP}" "${ORIG_IMAGE}"
          echo "Kernel image successfully patched with KPM. New Image.lz4 is in place."
          ls -l "${ORIG_IMAGE}"

      - name: Prepare Artifacts for Packaging
        run: |
          # Директории для артефактов
          ARTIFACT_DIR="kernel_source/out/${{ inputs.device }}/dist"
          ANYKERNEL_DIR="AnyKernel3"
          MKBOOTIMG_DIR="FilesForImg"

          echo "Preparing artifacts from $ARTIFACT_DIR"
        
          # Создаем обе целевые директории
          mkdir -p "$ANYKERNEL_DIR"
          
          # Подготовка для AnyKernel3
          cp "$ARTIFACT_DIR/Image.lz4" "$ANYKERNEL_DIR/Image.lz4"
          cat "$ARTIFACT_DIR"/*.dtb > "$ANYKERNEL_DIR/dtb"
        
          # Подготовка для создания .img файлов
          cp "$ARTIFACT_DIR/Image.lz4" "$MKBOOTIMG_DIR/assets"
          cat "$ARTIFACT_DIR"/*.dtb > "$MKBOOTIMG_DIR/assets/dtb"

          echo "Artifacts prepared successfully."
          ls -l "$ANYKERNEL_DIR"
          ls -l "$MKBOOTIMG_DIR"

      - name: Create ZIP Files for Different Formats
        working-directory: AnyKernel3
        run: |
          SUSFS_STAT="${{ inputs.susfs == 'true' && '_SUSFS-v1.5.9' || '' }}"
          echo "SUSFS_STAT=$SUSFS_STAT" >> $GITHUB_ENV

          ZIP_NAME="AK3_${KERNEL_VER}_${{ inputs.device }}_${{ inputs.ksu_type }}-v${KSUVER}${SUSFS_STAT}_${{ inputs.hooks_type }}.zip"
          echo "Creating zip file $ZIP_NAME..."
          zip -r "../$ZIP_NAME" ./*

          # export ZIP_NAME for later steps
          echo "ZIP_NAME=$ZIP_NAME" >> $GITHUB_ENV

      - name: Build boot.img and vendor_kernel_boot.img
        working-directory: FilesForImg
        run: |
          set -ex

          TOOLS_DIR="tools"
          ASSETS_DIR="assets"
          OUTPUT_DIR="output"
          TMP_DIR="tmp_build"

          # Получаем абсолютные пути, чтобы они работали после смены директории (cd)
          BASE_DIR="$PWD"
          MAGISKBOOT="$BASE_DIR/$TOOLS_DIR/magiskboot"

          # Подготовка
          echo "Preparing workspace..."
          mkdir -p "$OUTPUT_DIR" "$TMP_DIR"

          # Формируем имена файлов для экспорта
          BOOT_NAME="boot_${KERNEL_VER}_${{ inputs.device }}_${{ inputs.ksu_type }}-v${KSUVER}${SUSFS_STAT}_${{ inputs.hooks_type }}.img"
          VENDOR_NAME="vendor_kernel_boot_${KERNEL_VER}_${{ inputs.device }}_${{ inputs.ksu_type }}-v${KSUVER}${SUSFS_STAT}_${{ inputs.hooks_type }}.img"
          echo "BOOT_NAME=$BOOT_NAME" >> $GITHUB_ENV
          echo "VENDOR_NAME=$VENDOR_NAME" >> $GITHUB_ENV

          # Пересборка boot.img
          echo "==> Repacking boot.img..."

          cd "$TMP_DIR"

          "$MAGISKBOOT" unpack "$BASE_DIR/$ASSETS_DIR/boot.img"
          cp "$BASE_DIR/$ASSETS_DIR/Image.lz4" kernel
          "$MAGISKBOOT" repack "$BASE_DIR/$ASSETS_DIR/boot.img" "$BASE_DIR/$OUTPUT_DIR/$BOOT_NAME"
          echo "$BOOT_NAME created."

          # Возвращаемся в основную директорию проекта
          cd "$BASE_DIR"

          # Пересборка vendor_kernel_boot.img
          echo "Repacking vendor_kernel_boot.img..."

          # Снова переходим во временную директорию очистив ее от файлов boot.img
          rm -rf $TMP_DIR/*
          cd "$TMP_DIR"

          "$MAGISKBOOT" unpack "$BASE_DIR/$ASSETS_DIR/vendor_kernel_boot.img"
          cp "$BASE_DIR/$ASSETS_DIR/dtb" dtb
          "$MAGISKBOOT" repack "$BASE_DIR/$ASSETS_DIR/vendor_kernel_boot.img" "$BASE_DIR/$OUTPUT_DIR/$VENDOR_NAME"
          echo "$VENDOR_NAME created."

          # Возвращаемся в основную директорию проекта
          cd "$BASE_DIR"

          echo "==> Cleaning up..."
          rm -rf "$TMP_DIR"

          cp ${OUTPUT_DIR}/*.img -d ../

          echo "Build finished successfully."

      - name: Compress Image Files with Gzip
        run: |
          echo "Compressing .img files..."
          gzip -9 boot_*.img
          gzip -9 vendor_kernel_boot_*.img
          
          echo "Compression complete. Listing final files:"
          ls -lh *.zip *.gz

      - name: Upload AnyKernel ZIP Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ZIP_NAME }}
          path: AK3*.zip
          if-no-files-found: warn
          compression-level: 6
          overwrite: false
          include-hidden-files: false

      - name: Upload boot.img Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BOOT_NAME }}
          path: boot_*.img.gz
          if-no-files-found: warn
          compression-level: 6
          overwrite: false
          include-hidden-files: false

#      - name: Upload vendor_kernel_boot.img Artifact
#        uses: actions/upload-artifact@v4
#        with:
#          name: ${{ env.VENDOR_NAME }}
#          path: vendor_kernel_boot_*.img.gz
#          if-no-files-found: warn
#          compression-level: 6
#          overwrite: false
#          include-hidden-files: false

      - name: Start VS Code if fail build
        if: failure()      
        uses: fawazahmed0/action-debug-vscode@main
        with:
          port: 8080
          folder: ${{ github.workspace }}
          github_token: ${{ secrets.GITHUB_TOKEN }}